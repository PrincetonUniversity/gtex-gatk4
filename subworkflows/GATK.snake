if "subw_outputs_dict" in locals() and "ids" in locals():
    subw_outputs_dict['GATK'] = expand(paths['haplotype_output'],
                                       id=ids,
                                       chromosome=range(21,23))
    subw_outputs_dict['GATK'].extend(expand(paths['recal_covariates'], id=ids))

rule fastq_to_ubam:
    input:
        R1=paths['fastq_R1'],
        R2=paths['fastq_R2']

    output:
        temp(paths['ubam'])

    singularity:
        paths['container']

    resources:
        fastq_instances=1

    shell:
        'zcat {input.R1} | '
        'python {paths[base]}/scripts/split_fastq.py {input.R1} & \n'
        'zcat {input.R2} | '
        'python {paths[base]}/scripts/split_fastq.py {input.R2} \n'
        'wait \n'
        'RG1=($(python {paths[base]}/scripts/get_fastq.py {input.R1})) \n'
        'RG2=($(python {paths[base]}/scripts/get_fastq.py {input.R2})) \n'
        'TEMP_UBAMS=() \n'
        'UBAMS_ARG=() \n'
        'for i in ${{!RG1[@]}}; do \n'
            'TEMP_UBAM=$(dirname ${{RG1[$i]}})/$(basename ${{RG1[$i]}} | '  
                'cut -d"." -f 1 | cut -d "_" -f 1-3).ubam  \n'
            'RG=$(basename ${{RG1[$i]}} | cut -d "_" -f 2,3 | tr "_" "."i)  \n'
            'gatk --java-options "-Xmx{config[gatk][FastqToSam][memory]}" '
                'FastqToSam '
                '-F1=${{RG1[$i]}} '
                '-F2=${{RG2[$i]}} '
                '-SM={wildcards.id} '
                '-RG=${{RG}}.{wildcards.id} '
                '-PU=${{RG}}.{wildcards.id} '
                '-O=$TEMP_UBAM '
                '--VERBOSITY={config[gatk][verbosity]} '
                '{config[gatk][FastqToSam][options]} \n'
            'TEMP_UBAMS+=($TEMP_UBAM)  \n'
            'UBAMS_ARG+=(-I $TEMP_UBAM)  \n'
        'done  \n'
        'gatk --java-options "-Xmx{config[gatk][MergeSamFiles][memory]}" '
            'MergeSamFiles '
            '{config[gatk][MergeSamFiles][options]} '
            '--VERBOSITY={config[gatk][verbosity]} '
            '-O {output} '
            '${{UBAMS_ARG[*]}} \n'
        'rm ${{RG1[@]}} ${{RG2[@]}}  \n'
        'rm ${{TEMP_UBAMS[*]}}'

rule mark_adapters:
    input:
        paths['ubam']

    output:
        bam=temp(paths['marked_bam']),
        metric=paths['marked_metric']

    singularity:
        paths['container']

    shell:
        'gatk --java-options "-Xmx{config[gatk][MarkIlluminaAdapters][memory]}" '
            'MarkIlluminaAdapters '
            '-I={input} '
            '-O={output.bam} '
            '-M={output.metric} '
            '--VERBOSITY={config[gatk][verbosity]} '
            '--TMP_DIR={paths[temp_dir]} '

rule sam_to_fastq:
    input:
        marked=paths['marked_bam']

    output:
        pipe(paths['marked_fastq'])

    singularity:
        paths['container']

    group: 'map_bam'

    shell:
        'gatk --java-options "-Xmx{config[gatk][SamToFastq][memory]}" '
            'SamToFastq '
            '-I={input.marked} '
            '--FASTQ={output} '
            '--VERBOSITY={config[gatk][verbosity]} '
            '--TMP_DIR={paths[temp_dir]} '
            '{config[gatk][SamToFastq][options]}'

rule map_bam:
    input:
        marked=paths['marked_fastq']

    output:
        pipe(paths['temp_mapped_bam'])

    group: 'map_bam'

    shell:
        'bwa mem '
            '{config[gatk][Bwa_Mem][options]} '
            '-p {paths[ref_genome]} '
            '{input.marked} > {output} '
            '2>/dev/null'

rule merge_bam:
    input:
        bam=paths['temp_mapped_bam'],
        ubam=paths['ubam']

    output:
        bam=temp(paths['mapped_bam']),
        bai=temp(paths['mapped_bai'])

    singularity:
        paths['container']

    group: 'map_bam'

            #'--TMP_DIR={paths[temp_dir]} '
    shell:
        'gatk --java-options "-Xmx{config[gatk][MergeBamAlignment][memory]}" '
            'MergeBamAlignment '
            '--ALIGNED_BAM={input.bam} '
            '--UNMAPPED_BAM={input.ubam} '
            '--OUTPUT={output.bam} '
            '-R {paths[ref_genome]} '
            '--VERBOSITY={config[gatk][verbosity]} '
            '--TMP_DIR={paths[temp_dir]} '
            '{config[gatk][MergeBamAlignment][options]}'

rule dedup_bam:
    input:
        bam=paths['mapped_bam'],
        bai=paths['mapped_bai']

    output:
        bam=temp(paths['dedup_bam']),
        metric=paths['dedup_metric'],
        bai=temp(paths['dedup_bai'])

    singularity:
        paths['container']

    shell:
        'gatk --java-options "-Xmx{config[gatk][MarkDuplicates][memory]}" '
            'MarkDuplicates '
            '-I={input.bam} '
            '-O={output.bam} '
            '--METRICS_FILE={output.metric} '
            '--VERBOSITY={config[gatk][verbosity]} \n'
        'samtools index {output.bam}'

def get_bam(wildcards):
    if wildcards.type == 'before':
        return paths['dedup_bam']
    elif wildcards.type == 'after':
        return paths['recal_bam']
    else:
        raise ValueError("Unknown bqsr table type {}".format(wildcards.type))

rule bqsr_table:
    input:
        get_bam

    output:
        paths['recal_table']

    singularity:
        paths['container']

    shell:
        'gatk --java-options "-Xmx{config[gatk][BQSR][memory]}" '
            'BaseRecalibrator '
            '-R {paths[ref_genome]} '
            '-L {config[gatk][BQSR][target_intervals]} '
            '--verbosity {config[gatk][verbosity]} '
            '-I {input} '
            '-O {output} '
            '{config[gatk][BQSR][known_sites]} '

def get_before_table(wildcards):
    return {'bam': paths['dedup_bam'],
            'bai': paths['dedup_bai'],
            'table': paths['recal_table'].replace('{type}', 'before')}

rule bqsr_bam:
    input:
        unpack(get_before_table)

    output:
        bam=paths['recal_bam']

    singularity:
        paths['container']

    shell:
        'gatk --java-options "-Xmx{config[gatk][BQSR][memory]}" '
            'ApplyBQSR '
            '-R {paths[ref_genome]} '
            '--verbosity {config[gatk][verbosity]} '
            '-bqsr {input.table} '
            '-I {input.bam} '
            '-O {output.bam}'

def get_tables(wildcards):
    return {'before': paths['recal_table'].replace('{type}', 'before'),
            'after': paths['recal_table'].replace('{type}', 'after')}

rule analyze_bqsr:
    input:
        unpack(get_tables)

    output:
        paths['recal_covariates']

    singularity:
        paths['container']

    shell:
        'gatk --java-options "-Xmx{config[gatk][BQSR][memory]}" '
            'AnalyzeCovariates '
            '--verbosity {config[gatk][verbosity]} '
            '-before {input.before} '
            '-after {input.after} '
            '-plots {output}'

rule haplotype_caller:
    input:
        bam=paths['recal_bam'],
        interval=paths['haplotype_intervals']

    output:
        paths['haplotype_output']

    singularity:
        paths['container']

    shell:
        'gatk --java-options "-Xmx{config[gatk][HaplotypeCaller][memory]}" '
            'HaplotypeCaller  '
            '--verbosity {config[gatk][verbosity]} '
            '-R {paths[ref_genome]} '
            '-I {input.bam} '
            '-L {input.interval} '
            '-O {output} '
            '{config[gatk][HaplotypeCaller][options]}'

rule name_map:
    output:
        temp(paths['name_map'])

    run:
        import glob
        import os
        with open(output[0], 'w') as outfile:
            # get variants in output
            variant_dir = os.path.split(paths['haplotype_output'])[0]
            variant_dir = variant_dir.replace('{chromosome}', wildcards.chromosome)
            # get variants in 1000 genomes
            supp_dir = paths['1000G_dir'].replace('{chromosome}', wildcards.chromosome)

            split_chars = ['.', '_']
            for i, d in enumerate([variant_dir, supp_dir]):
                for f in glob.glob(d + "/*.g.vcf"):
                    sample = os.path.split(f)[1]
                    sample = sample[:sample.find(split_chars[i])]  # remove after first .
                    #outfile.write(
                    print(
                        "{}\t{}\n".format(
                            sample,
                            f))

#TODO: genomics db import and genotype, make the name map a piped/temp file to generate with snakemake
